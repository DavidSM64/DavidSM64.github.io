{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-green",
    "glyph" : "magic"
  },
  "name" : "Splatoon 3",
  "script" : "const SPLATOON_3_INK_SCHEDULE_URL = \"https:\/\/splatoon3.ink\/data\/schedules.json\";\n\n\/\/ Local filemanager to cache data to.\nconst fm = FileManager.local();\n\nconst CACHE_DIR = fm.cacheDirectory();\n\nconst CACHE_FILE = CACHE_DIR + \"\/\" + \"splatoon3ink_cache.txt\";\n\nconst DEBUG_SKIP_IMG_CACHE = false;\n\nlet cached_images = {};\n\nfunction isCachedFileOutOfDate() {\n  let currentDate = new Date();\n  let lastDate = fm.modificationDate(CACHE_FILE);\n  \n  if(currentDate.getHours() != lastDate.getHours()) {\n    return true;\n  }\n  \n  let cachedDataStr = fm.readString(CACHE_FILE);\n  let cachedDataJson = JSON.parse(cachedDataStr)[\"data\"];\n  \n  let endDateStr = cachedDataJson[\"regularSchedules\"][\"nodes\"][0].endTime;\n  let endDate = new Date(endDateStr);\n  let dateDiff = endDate - currentDate;\n  if(dateDiff < 0) {\n    return true;\n  }\n  \n  return false;\n}\n\nasync function getImageFromURL(imgUrl) {\n  \/\/ First check if the image is already loaded.\n  if(cached_images[imgUrl] != undefined) {\n    console.log(imgUrl + \": \" + cached_images[imgUrl]);\n    return cached_images[imgUrl];\n  }\n  \/\/ Second check if the image is on the device's cache directory.\n  let localFilepath = CACHE_DIR + \"\/\" + fm.fileName(imgUrl, true);\n  let localFileExists = fm.fileExists(localFilepath);\n  \n  if(localFileExists && !DEBUG_SKIP_IMG_CACHE) {\n    cached_images[imgUrl] = fm.readImage(localFilepath);\n    return cached_images[imgUrl];\n  }\n  \n  \/\/ Image is not in local cache directory, so load it from a url.\n  let newImg = await new Request(imgUrl).loadImage();\n  \n  \/\/ Write image to cache filepath\n  fm.writeImage(localFilepath, newImg);\n  \/\/ Cache image\n  cached_images[imgUrl] = newImg;\n  \/\/ Return the new image.\n  return newImg;\n}\n\nclass Splatoon3Stage {\n  constructor(name, imgUrl) {\n    this.name = name;\n    this.imgUrl = imgUrl;\n    console.log(this.name);\n    console.log(this.imgUrl);\n  }\n  \n  async add_to_widget(widget) {\n    let stack = widget.addStack();\n\t\tstack.setPadding(1, 1, 1, 1);\n    stack.centerAlignContent();\n    let img = await getImageFromURL(this.imgUrl);\n    let stageImg = stack.addImage(img);\n    stack.addSpacer();\n    let stageName = stack.addText(this.name);\n    stack.addSpacer();\n  }\n}\n\nclass Splatoon3GameMode {\n  constructor(mode, color, stages) {\n    this.mode = mode;\n    this.color = color;\n    this.stages = stages;\n  }\n  \n  async add_to_widget(widget) {\n    let heading = widget.addText(this.mode);\n  heading.centerAlignText();\n  heading.font = Font.lightSystemFont(20);\n  heading.textColor = this.color;\n    \n    for(let stage of this.stages) {\n      await stage.add_to_widget(widget);\n    }\n  }\n}\n\nasync function getSplatoon3InkData() {\n\t\tlet foundCacheFile = false;\n    \n    \/\/ First check if the cache file exists.\n\t let cacheFileExists = fm.fileExists(CACHE_FILE)\n  \n  if(cacheFileExists) {\n    if(!isCachedFileOutOfDate()) {\n      foundCacheFile = true;\n      console.log(\"Using cached data!\");\n    }\n  }\n\t\n  \/\/ No cache file found, get the data and store it to cache.\n  if(!foundCacheFile) {\n    const request = new Request(SPLATOON_3_INK_SCHEDULE_URL);\n    const jsonText = await request.loadString();\n    fm.writeString(CACHE_FILE, jsonText);\n  }\n  let cachedDataStr = fm.readString(CACHE_FILE);\n  return JSON.parse(cachedDataStr)[\"data\"];\n}\n\nfunction getTurfWarStages(splatData) {\n  if(splatData == undefined) {\n    throw new Error(\"splat data is undefined!\");\n  }\n  \n  const turfSched = splatData[\"regularSchedules\"];\n  const turfSchedNodes = turfSched[\"nodes\"];\n  const nowNode = turfSchedNodes[0];\n  const stagesInfo = nowNode[\"regularMatchSetting\"];\n  const stages = stagesInfo[\"vsStages\"];\n  const stage0 = stages[0];\n  const stage1 = stages[1];\n  let outStages = [\n    new Splatoon3Stage(stage0.name, stage0[\"image\"].url),\n    new Splatoon3Stage(stage1.name, stage1[\"image\"].url)\n  ];\n  return new Splatoon3GameMode(\"Turf War\", new Color(\"5ABF40\"), outStages);\n}\n\nfunction getAnarchyStages(splatData, type=0) {\n\tconst anarSched = splatData[\"bankaraSchedules\"];\n  const anarSchedNodes = anarSched[\"nodes\"];\n  const nowNode = anarSchedNodes[0];\n  const stagesInfo = nowNode[\"bankaraMatchSettings\"][type];\n    const stages = stagesInfo[\"vsStages\"];\n    const mode = (type == 0 ? \"Series\" : \"Open\") + \" (\" + stagesInfo[\"vsRule\"][\"name\"] + \")\";\n    const stage0 = stages[0];\n    const stage1 = stages[1];\n    let outStages = [\n      new Splatoon3Stage(stage0.name, stage0[\"image\"].url),\n      new Splatoon3Stage(stage1.name, stage1[\"image\"].url)\n    ];\n    return new Splatoon3GameMode(mode, new Color(\"#D2512A\"), outStages);\n}\n\nasync function addContent(widget){\n  let splatData = await getSplatoon3InkData();\n  let turfWarStages = getTurfWarStages(splatData);\n  let anarchySeriesStages = getAnarchyStages(splatData, 0);\n  let anarchyOpenStages = getAnarchyStages(splatData, 1);\n  \n  await turfWarStages.add_to_widget(widget);\nwidget.addSpacer();\n    await anarchySeriesStages.add_to_widget(widget);\n    widget.addSpacer();\n  await anarchyOpenStages.add_to_widget(widget);\n\t \/*let stageNames = widget.addText();\n  stageNames.centerAlignText();\n  stageNames.font = Font.lightSystemFont(25);\n  stageNames.textColor = new Color(\"#22FF99\");*\/\n  \n  \n}\n\nasync function createWidget() {\n  let listwidget = new ListWidget();\n  \n  await addContent(listwidget);\n  \n  return listwidget;\n}\n\nlet widget = await createWidget();\n\nif(config.runsInWidget) {\n  Script.setWidget(widget);\n} else {\n  widget.presentLarge();\n}\nScript.complete();\n",
  "share_sheet_inputs" : [

  ]
}